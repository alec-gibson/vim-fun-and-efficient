\documentclass{beamer}

\usepackage{subfig}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage[Q=yes]{examplep}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\mode<presentation> {
    \usetheme{Madrid}
}

\title[\textcolor{white}{Vim - Fun and Efficient}]{\huge Vim \\
    \large Making text editing fun and efficient
}

\author{Alec Gibson}
\institute[BlueCat]
{
    BlueCat Networks \\
    \medskip
    \textit{agibson@bluecatnetworks.com}
}
\date{November 24, 2020}

\begin{document}

\begin{frame}[fragile]
    \titlepage % Print the title page as the first slide
\end{frame}

\begin{frame}[fragile]
    \frametitle{Presentation Details}
    \begin{itemize}
	\item This presentation was created in Neovim 0.5.0 using the Beamer Latex package
	\item The source code is available at \url{https://github.com/alec-gibson/vim-fun-and-efficient}
	\item For discussions about Vim, please post in the company \#vim-geeks slack channel!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Disclaimer}
    \small The target audience of this talk is not seasoned users of Vi-family editors (though you are more than welcome to stay if this describes you). Many of the features I will refer to as Vim features were Vi features first. I never used Vi, and clarifying when features were introduced in Vim's lineage is outside the scope of this talk. So for the purpose of this talk they are Vim features.\\
    \vspace{0.5cm}
    Furthermore, almost everything I say in this talk applies equally to Neovim as it does to Vim. Neovim is a fork of Vim with slightly tweaked default options, no Benevolent Dictator For Life, and which tends to implement new features more quickly. I personally use Neovim instead of Vim, but both operate extremely similarly.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Goal}
    \small
    After learning Vim's basics in university, I decided to start using it full-time when I started working at BlueCat at the beginning of May. At first, my workflow was quite inefficient --- all my knowledge came from vimtutor, and several Reddit posts I had read. Since then, my knowledge of Vim has expanded massively, and my editing has become much more fluent, so I wanted to share what I've learned with other interested developers.\\
    \vspace{0.5cm}
    This talk is meant to make it easier for other developers to make the same transition as me, from a standard point-and-click text editor or IDE to Vim. I try to cover many of Vim's core features, so that you have some idea what it is capable of (which is a considerable amount) instead of immediately reaching for plugins. Where possible, I try to mention what features I have found particularly useful, and to outline why I feel learning Vim has been a net positive to my work as a developer. No section of this talk is exhaustive - Vim's feature set is so huge that covering any topic exhaustively would take forever and be very boring. Instead I try to cover the most important stuff, and reference documentation so you can learn the rest at your leisure.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview}
    \tableofcontents
\end{frame}

\section{About Vim}

\begin{frame}[fragile]
    \frametitle{About Vim}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]
    \frametitle{What is Vim}
    \centerline{\large According to vim.org}
    \vspace{0.5cm}
    \small Vim is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as \enquote{vi} with most UNIX systems and with Apple OS X.\\
    \vspace{0.5cm}
    Vim is rock stable and is continuously being developed to become even better. Among its features are:\\
    \begin{itemize}
	\item persistent, multi-level undo tree
	\item extensive plugin system
	\item support for hundreds of programming languages and file formats
	\item powerful search and replace
	\item integrates with many tools
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \centerline{\large Here are some important features I think were missed:}
    \vspace{0.5cm}
    \small
    \begin{itemize}
	\item Vim is very lightweight, meaning it runs smoothly on any modern computer and performs well over SSH.
	\item Vim's startup time is nearly instantaneous.
	\item Because Vim runs in a terminal it works nicely with other terminal utilities (like tmux), and you can pipe the output of scripts directly into Vim.
	\item Vim's configuration is scriptable, so you can define custom functions then use them in commands and keybindings.
	\item Once you learn Vim you can use it everywhere - its keybindings are supported in most other editors either natively or through plugins (including VSCode, Emacs, and IntelliJ to name a few)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \centerline{\large And most importantly....}
    \vspace{0.5cm}
    \small \textbf{If you have not used them before, learning Vim's keybindings will provide you with an extremely efficient way to edit text files.}\\
\end{frame}

\begin{frame}[fragile]
    \frametitle{Who Should Try Vim?}
    \centerline{\large You may appreciate Vim if you:}
    \vspace{0.5cm}
    \begin{itemize}
	\item Spend a large amount of your day editing plain text files (common in software development and IT)
	\item Make frequent use of your terminal emulator
	\item Appreciate the value of keyboard shortcuts
	\item Like to customize your tools to suit your workflow
	\item Want to make an investment in learning a single editor which works for every programming language
	\item \textbf{And especially} if you need a way to automate performing boring, repetitive edits to file
    \end{itemize}
\end{frame}

\section{A Minimal Vim Workflow}

\begin{frame}[fragile]
    \frametitle{A Minimal Vim Workflow}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]
    \frametitle{Modal Editing}
    \small
    \begin{block}{Modal Editing}
	Vim is a modal text editor, meaning keypresses in Vim perform different actions depending upon the editor's current \enquote{mode}.\\
    \end{block}
    When you edit a file in Vim, the editor starts in \enquote{normal} mode. This can confuse new users, because Vim's normal mode treats every key on the keyboard as a binding for a shortcut. To start off learning Vim, let's look at the smallest possible set of features you need to edit files.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Basic Vim File Operations}
    \small
    \begin{itemize}
	\item To open a file in Vim, type \verb+vim {filename}+ in your terminal emulator.
	\item To change the current open file, type \verb+:e /path/to/file<CR>+ (including the colon at the start).
	\item To save the current file, type \verb+:w<CR>+.
	\item Finally, to exit Vim type \verb+:q<CR>+.
    \end{itemize}
    \begin{block}{What's That CR Symbol?}
	\verb+<CR>+ is how you represent the Enter/Return key in Vim keybindings.
    \end{block}
    \begin{block}{Popular Variants}
	Popular variants of these commands include \verb+:wq<CR>+ to save and quit, and \verb+:wq!<CR>+ to force Vim to save and quit (ignoring any warnings while doing so).
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Basic Vim Editing}
    \small
    The simplest (though probably the slowest) way to navigate a file in Vim is using the arrow keys. To make changes in the current file, press \verb+i+ to enter \enquote{insert} mode. In insert mode, keys behave the way they would in any other text editor - letter and number keys insert their corresponding characters, and \verb+<BS>+ (backspace) deletes the previous character. \\
    \vspace{0.5cm}
    If you want to run any of the file operations from the previous slide, just press \verb+<ESC>+ (escape) to return to normal mode first.
    \begin{block}{Using Your Mouse in Vim!?}
	It's true, Vim supports using your mouse. Just set the required option by typing \verb+:set mouse=a+ in normal mode.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small This is enough Vim to edit config files on servers over SSH (albeit slowly), or to use while setting up a minimal Linux installation on a PC. \\
    \vspace{0.5cm}
    However, if this was the most efficient way to edit files in Vim, \textbf{the editor would have died out long ago}.
\end{frame}

\section{Vim Can Do More}

\begin{frame}[fragile]
    \frametitle{Vim Can Do More}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]
    \frametitle{Why The Minimal Workflow Isn't Enough}
    \small
    The minimal Vim workflow I described in the previous section is seriously inefficient. Here are a few reasons why:
    \begin{itemize}
	\item Using the mouse requires you to take your right hand off the keyboard
	\item Using the arrow keys requires you to take your right hand off the home row
	\item You can only move one character at a time using the arrow keys
	\item You can only delete one character at a time using \verb+<BS>+
	\item If your cursor is in the middle of some text, you have to move to the end to delete it
	\item We don't have any way to copy and paste
	\item We don't have a way to undo mistakes
	\item This workflow doesn't include any way to search the current file
	\item Repeated edits need to be executed manually each time
    \end{itemize}
    Vim's normal mode has features which solve all these issues.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Movement Keybindings}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item Using the mouse requires you to take your right hand off the keyboard
	    \item Using the arrow keys requires you to take your right hand off the home row
	\end{itemize}
    \end{block}
    Vim solves these issues by using the keys \verb+h, j, k, and l+ as alternatives to the arrow keys while in normal mode. These behave in the following manner:
    \begin{description}
	\item[h] Move left one character
	\item[j] Move down one character
	\item[k] Move up one character
	\item[l] Move right one character
    \end{description}
    These keybindings are well-known enough that other programs which also use hjkl for navigation often refer to them as \enquote{Vim keys}.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Moving Longer Distances}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item You can only move one character at a time using the arrow keys
	\end{itemize}
    \end{block}
    Vim's normal mode contains many keybindings for moving more than one character at a time. Here are some I use frequently:
    \begin{itemize}
	\item \verb+w/b+:  Move forward/back by one word at a time
	\item \verb+0/$+:  Move to the start/end of the current line (use \verb+^+ instead of 0 to move to the first non-whitespace character of the line)
	\item \verb+<C-d>+/\verb+<C-u>+:  Move down/up by half a screen at a time
	\item \verb+gg/G+:  Move to the start/end of the current file
    \end{itemize}
    \begin{block}{Useful Keybindings: f and F}
	Typing f\{char\} searches the current line for the chosen character, and using F searches backwards. Pressing \enquote{;} jumps to the next occurrence, and pressing \enquote{,} goes to the previous occurence (very useful if you overshoot your target). This is often the fastest way to jump to a specific location on the current line.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small
    \begin{block}{Repeating Movements Multiple Times}
	Most Vim commands allow you to prepend a number to multiply their effects. For example:
	\begin{itemize}
	    \item typing \verb+5j+ in normal mode moves your cursor down 5 lines.
	    \item typing \verb+3w+ moves your cursor forward 3 words
	    \item typing \verb+10fe+ moves your cursor to the tenth occurence of the character \enquote{e} following it on the current line
	\end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Keybindings for Editing}
    \small
    Vim has a number of keybindings for editing the current file's contents. We can start with keybindings which operate on single characters:
    \begin{itemize}
	\item \verb+x+:  delete the character under the cursor
	\item \verb+r{char}+:  replace the character under the cursor with \{char\}
	\item \verb+~+:  swap the case of the character under the cursor
	\item \verb+<C-a>+/\verb+<C-x>+:  increment / decrement the number under the cursor
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Operating on Chunks of Text}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item You can only delete one character at a time using \verb+<BS>+
	\end{itemize}
    \end{block}
    Operating on chunks of text is a place where Vim's keybindings shine. Vim separates these edits into keybindings it calls \enquote{operators} and \enquote{motions}.
    \begin{block}{Operators}
	Operators are the verbs of the edit - they are things like \enquote{delete}, \enquote{change}, \enquote{yank} (Vim language for \enquote{copy}), \enquote{indent}, \enquote{format}, etc.
    \end{block}
    \begin{block}{Motions}
	Motions are like nouns - they define what the operator should operate on. Examples of motions would be \enquote{a word}, \enquote{until the end of the line}, or \enquote{to the end of the file}.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small
    Operators:
    \begin{itemize}
	\item \verb+d+:  delete
	\item \verb+c+:  change (delete, then enter insert mode)
	\item \verb+y+:  yank (copy)
	\item \verb+<+/\verb+>+:  increase / decrease indent
	\item \verb+=+:  format (works well for C-style languages, but is configurable)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \small
    Example Edits:
    \begin{itemize}
	\item \verb+dl+:  delete to the right (same as x)
	\item \verb+dh+:  delete to the left
	\item \verb+dw+:  delete word
	\item \verb+c$+:  change to the end of the line
	\item \verb+yG+:  yank to the end of the file
	\item \verb+dt_+:  delete to the next underscore $\ast$
    \end{itemize}
    $\ast$ Note: \verb+t+ and \verb+T+ act like \verb+f+ and \verb+F+, but they stop one character before the character being searched for. These are extremely useful for operating on all the text before a certain target character. \verb+Snake_case+, \verb+kebab-case+ and \verb+camelCase+ are used frequently in source code files, so it often works well to make your target character the next underscore, hypen, or a specific capital letter.
\end{frame}

\begin{frame}[fragile]
    \small
    \begin{block}{Shortcuts for Common Operations}
	There are also some special editing keybindings to make frequently required editing operations more convenient. Repeating the operator twice means to apply it to the current line (\verb+dd+ deletes the current line, \verb+yy+ yanks the current line, etc.). There are also shortcuts for when you capitalize the operators - \verb+D+ deletes to the end of the line, \verb+Y+ is equivalent to \verb+yy+, etc.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small
    For most motions, the easiest way to understand the behaviour of Vim edits is to imagine the behaviour of the cursor if you typed the motion without the operator, then the operator will be applied to the characters spanned by that motion. This is why, for example, \verb+dw+ doesn't delete the entire word the cursor is currently inside, but rather deletes from the current cursor position to the beginning of the next word.\\
    \vspace{0.5cm}
    Sometimes this is not the behaviour we want - sometimes we want to delete the entire word the cursor is currently inside. We will explore how to do this using \enquote{text objects} next.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Text Objects}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item If your cursor is in the middle of some text, you have to move to the end to delete it
	\end{itemize}
    \end{block}
    Up until now, the motions we have applied to operators have also been normal mode navigation keybindings. This is not always the case. After typing the operator but before the motion, Vim is in a special mode called \enquote{operator-pending} mode, and this mode has some of its own unique keybindings. Text objects are an example of keybindings for operator-pending mode. These keybindings let operators work on an area of text the cursor is already inside - for example the current word or the surrounding set of quotation marks.
\end{frame}

\begin{frame}[fragile]
    \small
    examples of text objects:
    \begin{itemize}
	\item \verb+iw/aw+: inner / around word
	\item \verb+is/as+: inner / around sentence
	\item \verb+ip/ap+: inner / around paragraph
	\item \verb+i"/a"+: inner / around quoted string
	\item \verb+i(/a(+: inner / around \verb+()+ block
	\item \verb+i[/a[+: inner / around \verb+[]+ block
	\item \verb+i{/a{+: inner / around \verb+{}+ block
    \end{itemize}
    Language plugins often add text objects, for example to operate on the contents of classes and functions.
\end{frame}

\begin{frame}[fragile]
    \small
    Each of the \enquote{inner} variants of the provided text objects ignore whitespace and surrounding delimiters. The \enquote{around} variants include the surrounding delimiters and whitespace. \\
    \vspace{0.5cm}
    For example, \verb+di"+ will delete the contents of the quotation marks the cursor is currently inside, but will not touch the quotation marks themselves. In contrast, \verb+da"+ will delete the contents of the quotation marks, the quotation marks, and surrounding whitespace. \\
    \vspace{0.5cm}
    To frame this differently, if you had a series of quoted strings separated by spaces, \verb+di"+ would delete the contents of the current string, but repeating it again would do nothing. In contrast, \verb+da"+ would delete the current quoted string so that the cursor ends on the next quoted string, so if you repeated the edit it would delete each quoted string in turn.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Pasting, or \enquote{Putting}}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item We don't have any way to copy and paste
	\end{itemize}
    \end{block}
    We've seen how to yank text already using the \verb+y+ operator. Now all you need to do to \enquote{put} it (Vim language for pasting) is to press \verb+p+.\\
    \vspace{0.5cm}
    It is important to know, deleting in Vim does not just delete the chosen text, but behaves more like the \enquote{cut} operation in other popular editors. That is to say, when you use the \verb+d+ operator, the deleted text will be the next thing \enquote{put} when the user presses \verb+p+.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Searching}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item This workflow doesn't include any way to search the current file
	\end{itemize}
    \end{block}
    Searching is very quick in Vim, and is often the fastest way to navigate a file. Press \verb+/+ to initiate a search, then type in the pattern to search for (patterns are regular expressions so, among other things, they can include wildcards) and press \verb+<CR>+ to start the search. To move to the next search result press \verb+n+ and to move to the previous result press \verb+N+. Here are a few other useful keybindings for searching:
    \begin{itemize}
	\item \verb+?+: start a search in the opposite direction
	\item \verb+q/+: view a history of previous search patterns (press \verb+<CR>+ on one to search for it in the current file)
	\item \verb+/<CR>+: search again using the most recently used search pattern
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Undo and Redo}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item We don't have a way to undo mistakes
	\end{itemize}
    \end{block}
    You can undo the most recent edit by pressing \verb+u+, and you can press \verb+u+ multiple times to continue undoing edits. An example of a single \enquote{edit} in Vim would be a single operator + motion combination. Everything you type from pressing \verb+i+ to enter insert mode until returning to normal mode is considered a single edit, so pressing \verb+u+ once will undo all of it.\\
    \vspace{0.5cm}
    You can press \verb+<C-r>+ to "redo" the most recently undone edit. Like with \verb+u+, you can repeatedly press \verb+<C-r>+ to redo more undone edits.\\
    \vspace{0.5cm}
    If you accidentally undo too much then edit the document, it is still possible to recover - Vim keeps track of your branching undos. We'll discuss this later in the Vim Power Tools section when we discuss the Undo Tree.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Repeating Edits}
    \small
    \begin{block}{Problem}
	\begin{itemize}
	    \item Repeated edits need to be executed manually each time
	\end{itemize}
    \end{block}
    We discussed on the previous slide what a single \enquote{edit} is in Vim. You can repeat the most recent edit by pressing the \verb+.+ key.\\
    \vspace{0.5cm}
    Effectively using \verb+.+ takes a lot of practice, and requires that you plan your edits to be repeatable. For example, if you run \verb+diw+ to delete a word, then \verb+i+ to enter insert mode and type its replacement, subsequent presses of \verb+.+ will perform the insertion but not the deletion. If you want the deletion to be included in the repeated edit, you could use \verb+ciw+ instead.\\
    \vspace{0.5cm}
    Vim supports many ways to repeat edits. I'll discuss macros, \verb+:substitute+ and \verb+:global+ in the \enquote{Power Tools} section of this talk. All of these are more flexible than the \verb+.+ key.
\end{frame}

\begin{frame}[fragile]
    \frametitle{How to Find Help}
    \small
    Vim comes with extensive documentation built-in, accessible using the \verb+:h+ command (short for \verb+:help+, which works too if you want to be verbose). If you want to look up what a particular keybinding does, you can run \verb+:h {key}<CR>+ to look up the corresponding help file. If you don't know the name of the help file you are looking for, you can run \verb+:helpgrep {phrase}<CR>+ to search all Vim's help files for a particular phrase. Helpgrep fills Vim's \enquote{quickfix} list with its results - we will discuss the quickfix list more later, but for now just know you can run \verb+:cnext<CR>+ to go to the next result and \verb+:cprev<CR>+ to go to the previous result.
\end{frame}

\begin{frame}[fragile]
    \frametitle{How to Learn Vim}
    \small
    If you want more thorough materials to learn Vim, you can start by running \verb+vimtutor+ in your terminal (it usually comes with your installation of Vim). After completing vimtutor, you can read Vim's user manual for a lengthy but readable guide to all of Vim's most important features. To read the user manual, run \verb+:h user-manual<CR>+ in Vim.
\end{frame}

\section{Power Tools}

\begin{frame}[fragile]
    \frametitle{Power Tools}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]
    \small
    Now that we've covered most of the basic features of Vim, you have seen one of the reasons many developers swear by it as their editor of choice - the ability to modularly compose edits using operators and navigation keybindings gives you a very terse language for quickly editing documents. However, there are probably still some people wondering \textbf{why would anyone want to use this editor}? Hopefully the features I discuss in this section will help make a stronger case in favour of Vim.
\end{frame}

\begin{frame}[fragile]
    \small
    To start with, I'll cover Command-Line Mode and Visual Mode to round out our understanding of Vim's modes. Then we'll get into some of (what I consider) Vim's killer features - the jump list, registers, macros, \verb+:substitute+, \verb+:global+, and the undo tree. By the end of this section I'll have explained enough of Vim's features that, if you became fluent in their usage, you could edit single files in Vim quite efficiently. \\
    \vspace{0.5cm}
    After this section, we'll cover ways to manage editing multiple files in a single Vim session, then we'll finish up with a short introduction to Vim configuration.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Command-Line Mode}
    \small
    Many of Vim's features are accessible using keybindings in normal mode. However, we can also access features by writing out the names of commands to execute using Vim's command-line mode. Press \verb+:+ to enter command-line mode, then you can type in the name of a command and hit \verb+<CR>+ to execute it and return to normal mode. If you change your mind, you can press \verb+<ESC>+ to go back to normal mode without executing a command.\\
    \vspace{0.5cm}
    \begin{block}{We've Seen This Before}
	We have already learned several Vim command-line mode commands. The file operations we learned (\verb+:w+, \verb+:q+ and \verb+:e+) all execute in command-line mode, as do the \verb+:h+ and \verb+:helpgrep+ commands. Vim doesn't require you to type the whole name of a command to execute it - you just need to type enough to disambiguate it from other commands. The file operations we learned are actually short forms for \verb+:write+, \verb+:quit+ and \verb+:edit+.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small
    \begin{block}{How Do I See My Command-Line History?}
	When you are in command-line mode, you can press the up and down arrow keys (or \verb+<C-p>+ and \verb+<C-n>+, emacs style) to select previously run commands. You can view your command-line history by typing \verb+q:+ in normal mode. This will open a window showing past commands you've run, where you can edit a previous command, then execute the edited version using \verb+<CR>+.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Visual Mode}
    \small
    One of the disadvantages of Vim's operator/motion syntax for defining an edit, is that you need to decide on the appropriate motion for an edit on the spot after already commiting to an operator. If you would prefer to make your selection of text to operate on first, then specify the operator after, Vim contains three different \enquote{visual modes} which allow you to do just that.
    \vspace{0.5cm}
    \begin{block}{Character-Wise Visual Mode}
	The simplest visual mode Vim offers is character-wise visual mode, often just refered to as visual mode. You can enter this visual mode by pressing \verb+v+, and exit to normal mode using \verb+<ESC>+. While in any visual mode, your current text selection will be highlighted. You can move the cursor to change where the visual selection ends, or press \verb+o+ to instead change where the selection starts. After making your selection you can use operators on the selected text, like \verb+d+ to delete it, or \verb+y+ to yank it.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small
    \begin{block}{Line-Wise Visual Mode}
	You can press \verb+V+ (capital V) to enter line-wise visual mode - a variant of visual mode which only selects entire lines. I often use this version of visual mode to delete or yank data which is formatted into separate lines, such as a function, a JSON object, or a chunk of YAML. It is also useful for constraining the scope of some command-line commands, something we'll explore more when we discuss the \verb+:substitute+ command.
    \end{block}
    \begin{block}{Block-Wise Visual Mode}
	You can press \verb+<C-v>+ to enter block-wise visual mode, which lets you select a rectangular region of text. I have found this most useful when I want to add, remove or modify a prefix for several lines. For example, if I wanted to create a bulleted list, I would use block-wise visual mode to select the first character of several lines, press \verb+I+ to insert at the start of each line's selection in the block (a special block-wise visual mode mapping), type \verb+-+, then press \verb+<ESC>+. Upon returning to normal mode, all my selected lines would be updated to begin with a hyphen.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{The Jump List}
    \small
    This is a simple feature, but it is \textbf{constantly} useful, and I wish every text editor had it. Vim keeps track of every time you use a motion to move a significant distance, and stores these locations you've jumped to in its \enquote{jump list}. You can view this jump list by running the \verb+:jumps+ command.\\
    \vspace{0.5cm}
    The useful part is that Vim lets you jump back to older locations you've been using \verb+<C-o>+ and newer locations using \verb+<C-i>+. This means for example, if you created a tags file using ctags, you could jump to a function's definition using \verb+<C-]>+. Then, using the jump list you could use \verb+<C-o>+ to jump back to where the function is called when you're done looking at it. I use this functionality constantly when reading new code I haven't seen before.\\
    \vspace{0.5cm}
    Note: the \verb+<C-]>+ keybinding also lets you jump to referenced help pages inside \verb+:help+.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Registers}
    \small
    Instead of using the system clipboard, Vim uses a large collection of \enquote{registers} to store text for use elsewhere. Many operators can be prefixed with a register name, to make them use that register. To tell Vim you are specifying a register, you start with \verb+"+ - a quotation mark - followed by a single key for the register name. For example:
    \begin{itemize}
	\item \verb+"ayy+: yank the current line, and put it into register \verb+a+
	\item \verb+"add+: delete the current line, and put it into register \verb+a+
	\item \verb+"ap+: insert the contents of register \verb+a+ at the cursor's location
    \end{itemize}
    You can also use a capital letter to tell Vim to append to a register instead of replacing the register's contents. Many of the non-character keys on the keyboard are also used for registers with special purposes (\verb+"+ is the default register, \verb+_+ is no register, \verb|+| can be configured to use the system clipboard, etc). You can learn more about these by reading \verb+:help registers+.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Macros}
    \small
    Vim allows you to execute arbitrary strings of characters stored in a register as a macro! For an easy way to record a macro, Vim provides a convenient keybinding - \verb+q+ - which allows you record a sequence of keypresses into a register. For example:
    \begin{itemize}
	\item \verb+qadwq+: record the characters \verb+dw+ into register \verb+a+
	\item \verb+qAdwq+: record the characters \verb+dw+ into register \verb+a+, appending to the current contents of the register
    \end{itemize}
    \vspace{0.5cm}
    Once you have recorded a macro into a register, you can the execute the macro using the \verb+@+ keybinding, followed by the name of the register to execute:
    \begin{itemize}
	\item \verb+@a+: execute the contents of register \verb+a+ as a macro
	\item \verb+@@+: execute the last executed macro again
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \small
    \begin{block}{Repeating Macros}
	Like most of Vim's commands, you can prefix the execution of a macro with a number to specify the number of times to repeat that macro. If Vim reaches the end of the current file while executing a macro, it stops executing it (this is useful, because you can include a search in your macro to find the next place to execute it).
    \end{block}
    \vspace{0.5cm}
    Because macros just execute the contents of a register, there are many ways to record a macro - you don't have to use \verb+q+! If you want, you could write the macro in your current file, then yank it into a register to execute it. Or you could record part of your macro in register \verb+a+, stop recording, then append to that same register using \verb+qA+. Vim's macro system is extremely flexible, and is a good way for repeating edits which are too complex to use the \verb+.+ key.
\end{frame}

\begin{frame}[fragile]
    \frametitle{:substitute}
    \small
    One of the more common features people use in a text editor is the ability to search for and replace a sequence of characters. To do this, Vim provides the \verb+:substitute+ command which has the following syntax:
    \vspace{0.5cm}
    \begin{block}{:substitute syntax}
	\verb+:[range]s[ubstitute]/{pattern}/{replacement}/[flags]+
    \end{block}
    \vspace{0.5cm}
    This syntax provides a great deal of flexibility, allowing you to match strings using a regular expression, use matched subexpressions in the pattern's replacement, and limit what lines to perform the substitution on. But before we get into these more advanced (but very much worth learning) features, we'll explore some examples of basic \verb+:substitute+ usage.
\end{frame}

\begin{frame}[fragile]
    \frametitle{:substitute examples}
    \small
    \begin{itemize}
	\item \verb+:s/asdf/qwerty+: replace the first occurence of \verb+asdf+ with \verb+qwerty+ on the current line
	\item \verb+:s/asdf/qwerty/g+: replace every occurence of \verb+asdf+ with \verb+qwerty+ on the current line (the \verb+g+ flag means replace every occurence instead of just the first one)
	\item \verb+:1,10s/asdf/qwerty/g+: replace every occurence of \verb+asdf+ with \verb+qwerty+ on lines 1 to 10 of the current file
	\item \verb+:%s/asdf/qwerty/g+: replace every occurence of \verb+asdf+ with \verb+qwerty+ on every line in the current file (Vim uses the range \verb+%+ as a synonym for \verb+1,$+, meaning every line in the current file)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Patterns}
    \small
    One of the best things about Vim's \verb+:substitute+ command is that it doesn't just match verbatim strings of characters, but instead uses a full system of regular expressions. Obviously, outlining all the regular expression rules would be too much for this presentation, but I'll list some of the features I use most often (this assumes the \enquote{magic} option is set, which effects what characters need to be escaped to take on a special meaning):
    \begin{itemize}
	\item \verb+.+: any character
	\item \verb+*+: any number of repetitions
	\item \verb+^+: the start of a line
	\item \verb+$+: the end of a line
	\item \verb+\(\)+: group contents into a subexpression (this subexpression can be used with \verb+*+, and can be referenced in the pattern's replacement)
    \end{itemize}
    There is much more that you can do with Vim's regular expression system. To learn more, read \verb+:help pattern+.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Using Matched Patterns in the Replacement}
    \small
    Often you want to perform a substitution, but provide some context so that you avoid the pattern matching false-positives. You can do this using subexpressions in your \verb+:substitute+ command's pattern. After using a pattern containing subexpressions, you can reference them in the replacement using \verb+\0+ to mean the whole matched pattern, and \verb+\{num}+ to mean the \verb+{num}+th subexpression. Here is an example which hopefully illustrates how useful this can be:\\
    \begin{verbatim}
    :%s/func \(.*\)(/func (s *MyStruct) \1(
    \end{verbatim}
    This command's pattern matches \enquote{func }, followed by an arbitrary string of characters (captured in a subexpression), followed by an opening bracket --- this is the pattern followed by a function definition in Golang. The replacement takes the function name, and replaces its prefix with \enquote{func (s *MyStruct) }. This substitute command could be used to turn all the functions in a file into methods for a struct you defined!
\end{frame}

\begin{frame}[fragile]
    \frametitle{Restricting a Substitution's Range}
    \small
    Sometimes I find that I want to perform a substitution only in a select portion of a file. For example, I might want to rename a variable inside a single function, but not touch variables of the same name in other functions. I have already shown that you can restrict \verb+:substitute+ by providing \verb+{start},{end}+ as the range. I never do this because Vim works so nicely with line-wise visual mode for setting ranges. Just select the lines you want to use as the range for your \verb+:substitute+, then press \verb+:+ and Vim will automatically insert \verb+'<,'>+ as the range. This range means the current visually selected lines, and it uses a pair of \enquote{marks} to denote these.
    \begin{block}{Marks}
	Marks are a feature Vim uses to store locations in files. I am going to annoy some Vim users by skipping discussing their usage in this talk, purely to save time and because I don't use them much personally. A good introduction to marks is provided in Vim's user manual, and you can read it by running \verb+:help 03.10+.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \small
    \begin{block}{One More Substitute Trick}
	You have seen the \verb+g+ flag for substitutions to make them replace every occurence, instead of just the first one on each line. Another flag I use frequently is \verb+c+, which makes \verb+:substitute+ ask for permission before performing each substitution. This is great if you only want to perform the substitution in some cases, and you're feeling too lazy to define a more complex regular expression to only match those specific cases.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{:global}
    \small
    When using macros, a fairly common workflow is to search for the next place to execute your macro, and include this search in the macro recording so that when you execute the macro many times, it automatically finds its next place to execute each time. A similar workflow can also be performed with the \verb+:global+ command, which uses the following syntax:\\
    \vspace{0.5cm}
    \begin{block}{:global syntax}
	\verb+:[range]g[lobal]/{pattern}/[command]+
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{:global commands}
    \small
    \verb+:global+ is extremely flexible --- it just runs the command you specify on matches for your provided pattern, using the same regular expression syntax as the \verb+:substitute+ command. If you don't provide a command, global uses \verb+:p[rint]+ by default, which prints the matching lines for you to view them. You could use \verb+:d[elete]+ to delete matching lines, or even \verb+:s[ubstitute]+ to perform a substitution only on lines which match the provided pattern. For the ultimate in flexibility, you can use the \verb+:norm[al]+ command to execute a string of keybindings in normal mode on matching lines.\\
    \vspace{0.5cm}
    \begin{block}{:global!}
	If you want to run a command starting at the beginning of lines which match your pattern, just use \verb+global!+ instead of \verb+global+.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{:normal and :execute}
    \small
    The \verb+:normal+ command provides a way for you to use normal mode keybindings in command-line mode. This is useful for some commands which run other command-line commands, such as \verb+:global+, or \verb+:cdo+ (which we'll learn about in the next section).\\
    \vspace{0.5cm}
    One difficulty with the \verb+:normal+ command is when you want to use a special character, such as \verb+<ESC>+ or \verb+<CR>+. When you want to do this, just wrap it in an \verb+:execute+ command, which takes a string containing a command and executes it in command-line mode, and allows you to escape special characters. For example:\\
    \begin{verbatim}
    :exe "norm ifunc \<ESC>A{"
    \end{verbatim}
    This command enters insert mode, types \enquote{func }, hits \verb+<ESC>+ to go back to normal mode, then inserts an opening curly brace at the end of the line.
\end{frame}

\begin{frame}[fragile]
    \frametitle{The Undo Tree}
    \small
	Here's a perilous situation which can occur in almost any editor: you edit a file for a while, and after making your edits, you realize you deleted something which you should not have deleted. To get that deleted text back, you \enquote{undo} multiple times, intending to copy the deleted text, so you can \enquote{redo} your changes and paste. However, you accidentally edit the file while in the older state! Now you can't redo your changes, and you've just accidentally lost all the work you had done!\\
	\vspace{0.5cm}
	Thankfully, Vim keeps track of your entire \enquote{undo tree} to avoid exactly this issue. The easiest way to use this feature is using the \verb+g-+ and \verb|g+| normal mode keybindings. These keybindings go to \enquote{older} and \enquote{newer} text states respectively, regardless of whether there were \enquote{undo} operations in the middle. In the situation I outlined, even though you'd performed an edit after undo-ing, you can just press \verb+g-+ to go to older text states until you have your edits back.
\end{frame}

\begin{frame}
	\begin{block}{Making the Undo Tree More Usable}
	I find the full power of Vim's undo tree is really unlocked with plugins for visualizing it, so you can easily walk to any node in the undo tree. The one I use is \url{https://github.com/mbbill/undotree}.
	\end{block}
\end{frame}

\section{Managing and Editing Multiple Files}

\begin{frame}[fragile]
    \frametitle{Managing and Editing Multiple Files}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]
    \frametitle{Buffers, Windows and Tabs}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Argument, Location and Quickfix Lists}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Grep and Vimgrep}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Cdo, Ldo, Argdo}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Finding Files Quickly}
    \small
    NOTE: discuss fuzzy finder and file tree plugins here
\end{frame}

\section{Configuration}

\begin{frame}[fragile]
    \frametitle{Configuration}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]
    \frametitle{Setting Options}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Keybindings}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Abbreviations}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Functions}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Custom Commands}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Automatic Commands}
    \small
\end{frame}

\begin{frame}[fragile]
    \frametitle{Plugins}
    \small
\end{frame}

\section{Links for Further Learning}

\begin{frame}[fragile]
    \frametitle{Links for Further Learning}
    \small
\end{frame}

\section{Goodbye}

\begin{frame}[fragile]
    \centerline{\huge All Praise VI VI VI}
    \vspace{0.5cm}
    \centerline{\huge Editor of The Beast}
    \begin{figure}
	\centering
	\subfloat{{\includegraphics[width=0.3\linewidth]{saintignucius.jpg} }}% Created by Wouter van Oortmerssen
	\qquad
	\subfloat{{\includegraphics[width=0.3\linewidth]{freebsd-daemon.png} }}% Created by Poul-Henning Kamp under the beer-ware license (https://svnweb.freebsd.org/base/head/share/examples/BSD_daemon/README?view=markup)
    \end{figure}
\end{frame}

\end{document} 
